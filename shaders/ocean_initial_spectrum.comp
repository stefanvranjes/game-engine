#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba32f) writeonly uniform image2D u_H0k;

uniform int u_N;
uniform int u_L;
uniform vec2 u_WindDirection;
uniform float u_WindSpeed;
uniform float u_Amplitude;

const float PI = 3.14159265359;
const float G = 9.81;

// Phillips Spectrum
float Phillips(vec2 k, vec2 w, float V, float A) {
    float k_len = length(k);
    if (k_len < 0.0001) return 0.0;
    
    float k2 = k_len * k_len;
    float k4 = k2 * k2;
    
    vec2 k_dir = normalize(k);
    vec2 w_dir = normalize(w);
    float k_dot_w = dot(k_dir, w_dir);
    
    float L = (V * V) / G; // Largest possible wave
    
    return A * (exp(-1.0 / (k2 * L * L)) / k4) * pow(abs(k_dot_w), 2.0);
}

// Random number generation (Gaussian)
// Based on Box-Muller transform
float rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

vec2 GaussianSigned(vec2 uv) {
    float u1 = max(rand(uv), 1e-6);
    float u2 = max(rand(uv + vec2(0.1, 0.1)), 1e-6); // offset
    
    float R = sqrt(-2.0 * log(u1));
    float T = 2.0 * PI * u2;
    
    return vec2(R * cos(T), R * sin(T));
}

void main() {
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    if (id.x >= u_N || id.y >= u_N) return;
    
    float n = float(u_N);
    float l = float(u_L);
    
    vec2 k;
    k.x = (2.0 * PI * (float(id.x) - n * 0.5)) / l;
    k.y = (2.0 * PI * (float(id.y) - n * 0.5)) / l;
    
    vec2 gauss = GaussianSigned(vec2(id) / n);
    
    float P = Phillips(k, u_WindDirection, u_WindSpeed, u_Amplitude);
    
    // h0(k) = 1/sqrt(2) * (Zr + i*Zi) * sqrt(P(k))
    vec2 h0 = gauss * sqrt(P) * 0.7071067;
    
    // h0(-k) conjugate
    vec2 k_inv = -k;
    float P_inv = Phillips(k_inv, u_WindDirection, u_WindSpeed, u_Amplitude);
    vec2 gauss_inv = GaussianSigned(vec2(id) / n + vec2(0.5, 0.5)); // Different seed?
    // Ideally seed implies conjugacy? No, distinct random variable for -k usually
    // Standard implementation: h0(k) and h0(-k) are distinct realizations
    
    vec2 h0_conj = gauss_inv * sqrt(P_inv) * 0.7071067;
    h0_conj.y = -h0_conj.y; // Conjugate
    
    // Store
    // R = Real(h0), G = Imag(h0)
    // B = Real(h0_conj), A = Imag(h0_conj)
    imageStore(u_H0k, id, vec4(h0, h0_conj));
}
