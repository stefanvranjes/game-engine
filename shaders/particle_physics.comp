#version 430 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Must match C++ GPUParticle layout
struct Particle {
    vec4 position;   // .xyz = pos, .w = size
    vec4 velocity;   // .xyz = vel, .w = lifetime
    vec4 color;      // rgba
    vec4 properties; // .x = age, .y = lifeRatio, .z = active (float), .w = padding
};

layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

layout(binding = 1, offset = 0) uniform atomic_uint activeCount;

layout(std430, binding = 2) buffer TrailBuffer {
    vec4 trailPoints[];
};

uniform float deltaTime;
uniform vec3 emitterPosition;
uniform vec3 gravity; // We need to ensure we set this uniform
uniform vec3 velocityMin;
uniform vec3 velocityMax;
uniform vec4 colorStart;
uniform vec4 colorEnd;
uniform float sizeStart;
uniform float sizeEnd;
uniform float particleLifetime;
uniform float spawnRate;
uniform float time;
uniform int maxParticles;

// Trail uniforms
uniform int u_EnableTrails;
uniform int u_TrailLength;

// Pseudo-random function
float random(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 randomVec3(vec3 seed) {
    return vec3(
        random(seed.xy),
        random(seed.yz),
        random(seed.zx)
    );
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= maxParticles) return;
    
    Particle p = particles[index];
    
    // Check if active
    if (p.properties.z > 0.5) {
        // Update Age
        p.properties.x += deltaTime; // age
        p.velocity.w -= deltaTime;   // lifetime
        
        if (p.velocity.w <= 0.0) {
            // Die
            p.properties.z = 0.0;
        } else {
            // Update Physics
            p.velocity.xyz += gravity * deltaTime;
            p.position.xyz += p.velocity.xyz * deltaTime;
            
            // Calculate life ratio (approximate if we don't store max lifetime persistently in a separate immutable way)
            // But we can approximate it: ratio = age / (age + remaining_lifetime)
            float totalLife = p.properties.x + p.velocity.w;
            p.properties.y = p.properties.x / totalLife;
            
            // Interpolate color and size
            p.color = mix(colorStart, colorEnd, p.properties.y);
            p.position.w = mix(sizeStart, sizeEnd, p.properties.y);
            
            // Update Trail
            if (u_EnableTrails != 0 && u_TrailLength > 1) {
                uint trailBase = index * u_TrailLength;
                
                // Shift points (Naive O(N) shift per thread - ok for small trail lengths)
                for (int i = u_TrailLength - 1; i > 0; --i) {
                    trailPoints[trailBase + i] = trailPoints[trailBase + i - 1];
                }
                
                // Add new point at head
                // Store position and current size (width)
                trailPoints[trailBase] = vec4(p.position.xyz, p.position.w);
            }
            
            // Increment active count for rendering
            atomicCounterIncrement(activeCount);
        }
        
        // Write back
        particles[index] = p;
    }
    // We could implement spawning here if we had a spawn queue, 
    // but the current architecture seems to rely on CPU spawning active particles 
    // or persistent mode where we just recycle?
    // The previous truncated file had respawn logic.
    // If the particle is dead, we check if we should respawn?
    // For now, let's assume CPU manages activation or we just update active ones.
    // If we want FULL GPU, we need spawn logic.
    // Let's add simple respawn logic if it's dead to keep the emitter running if it's supposed to be continuous.
    // But managing spawn rate on GPU is tricky without a global atomic accumulator.
    // The simple CPUParticleEmitter logic has m_SpawnAccumulator.
    // We'll stick to updating active particles for now to be safe, as mixing CPU/GPU logic is safer than broken GPU spawning.
}
