#version 430 core

// Work group size
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Particle structure matching CPU-side Particle struct
struct Particle {
    vec3 position;
    float life;
    vec3 velocity;
    float size;
    vec4 color;
    float rotation;
    float angularVelocity;
    float mass;
    float atlasIndex;
};

// Shader Storage Buffer Objects
layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

// Uniforms
uniform float deltaTime;
uniform vec3 gravity;
uniform vec3 emitterPosition;
uniform float particleLifetime;
uniform vec3 velocityMin;
uniform vec3 velocityMax;
uniform vec4 colorStart;
uniform vec4 colorEnd;
uniform float sizeStart;
uniform float sizeEnd;
uniform int maxParticles;
uniform float spawnRate;
uniform float time;

// Atomic counter for active particles
layout(binding = 1, offset = 0) uniform atomic_uint activeCount;

// Random number generation
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

vec3 randomVec3(vec3 seed) {
    return vec3(
        random(seed.xy),
        random(seed.yz),
        random(seed.zx)
    );
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (index >= maxParticles) {
        return;
    }
    
    Particle p = particles[index];
    
    // Update existing particle
    if (p.life > 0.0) {
        // Update lifetime
        p.life -= deltaTime;
        
        // Update physics
        p.velocity += gravity * deltaTime;
        p.position += p.velocity * deltaTime;
        p.rotation += p.angularVelocity * deltaTime;
        
        // Update color and size based on lifetime
        float lifeRatio = p.life / particleLifetime;
        p.color = mix(colorEnd, colorStart, lifeRatio);
        p.size = mix(sizeEnd, sizeStart, lifeRatio);
        
        // Write back
        particles[index] = p;
        
        // Increment active particle count
        atomicCounterIncrement(activeCount);
    }
    // Respawn dead particle (simple respawning logic)
    else if (p.life <= 0.0) {
        // Use particle index and time as seed for randomness
        vec3 seed = vec3(float(index), time, float(index) * 0.1);
        vec3 randVec = randomVec3(seed);
        
        // Reset particle
        p.position = emitterPosition;
        p.life = particleLifetime;
        p.velocity = mix(velocityMin, velocityMax, randVec);
        p.color = colorStart;
        p.size = sizeStart;
        p.rotation = randVec.x * 6.28318; // Random rotation 0-2Ï€
        p.angularVelocity = (randVec.y - 0.5) * 2.0; // Random angular velocity
        p.mass = 1.0;
        p.atlasIndex = 0.0;
        
        // Write back
        particles[index] = p;
        
        // Increment active particle count
        atomicCounterIncrement(activeCount);
    }
}
