#version 460 core
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#include "ddgi_common.glsl"

// Buffers
struct RayHit {
    vec4 val; // xyz = radiance, w = distance
};
layout(std430, binding = 0) writeonly buffer RayHitBuffer {
    RayHit hits[];
};

// Scene Buffers (Simplified)
// ... Include BVH / Vertex buffers here ...

// Uniforms
uniform mat4 randomVar; // Rotation matrix
uniform vec3 gridStart;
uniform vec3 gridStep;
uniform ivec3 gridDim;
uniform int raysPerProbe;
uniform float maxDist;

// Pseudo-random
float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// Fibonacci Sphere
vec3 sphericalFibonacci(int i, int n) {
    const float PHI = 1.61803398875;
    float phi = 2.0 * PI * (float(i) / PHI);
    float cosTheta = 1.0 - (2.0 * float(i) + 1.0) / float(n);
    float sinTheta = sqrt(clamp(1.0 - cosTheta * cosTheta, 0.0, 1.0));
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

void main() {
    uint rayIdx = gl_GlobalInvocationID.x;
    int totalProbes = gridDim.x * gridDim.y * gridDim.z;
    if (rayIdx >= totalProbes * raysPerProbe) return;

    int probeIdx = int(rayIdx) / raysPerProbe;
    int rayInProbe = int(rayIdx) % raysPerProbe;
    
    // Probe Position
    ivec3 coord = GetProbeGridCoord(probeIdx, gridDim);
    vec3 probePos = gridStart + vec3(coord) * gridStep;
    
    // Ray Direction
    // Use Fibonacci + Random Rotation
    vec3 baseDir = sphericalFibonacci(rayInProbe, raysPerProbe);
    vec3 dir = (randomVar * vec4(baseDir, 0.0)).xyz;
    
    // Trace (Placeholder simplified trace)
    // Real impl needs BVH traversal similar to probe_bake.comp
    // For demo, we just intersect a floor plane?
    float dist = maxDist;
    vec3 radiance = vec3(0.0); // Black Sky
    
    // Simple Floor Checky
    if (dir.y < 0.0) {
        float t = -probePos.y / dir.y;
        if (t > 0.0 && t < dist) {
            dist = t;
            radiance = vec3(0.5); // Grey floor
        }
    } else {
        // Sky
        radiance = mix(vec3(0.8, 0.9, 1.0), vec3(0.1, 0.3, 0.8), dir.y);
    }

    hits[rayIdx].val = vec4(radiance, dist);
}
