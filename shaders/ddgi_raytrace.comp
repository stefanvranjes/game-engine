#version 460 core
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#include "ddgi_common.glsl"

// Buffers
struct RayHit {
    vec4 val; // xyz = radiance, w = distance
};
layout(std430, binding = 0) writeonly buffer RayHitBuffer {
    RayHit hits[];
};

// Scene Buffers (Simplified)
// ... Include BVH / Vertex buffers here ...

// Uniforms
uniform mat4 randomVar; // Rotation matrix
// uniform vec3 gridStart; // Deprecated by Toroidal
uniform vec3 probeSpacing;
uniform ivec3 gridOrigin;
uniform ivec3 gridDim;
uniform int raysPerProbe;
uniform float maxDist;

// Pseudo-random
float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// Fibonacci Sphere
vec3 sphericalFibonacci(int i, int n) {
    const float PHI = 1.61803398875;
    float phi = 2.0 * PI * (float(i) / PHI);
    float cosTheta = 1.0 - (2.0 * float(i) + 1.0) / float(n);
    float sinTheta = sqrt(clamp(1.0 - cosTheta * cosTheta, 0.0, 1.0));
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

// Light Buffer
struct Light {
    vec4 position;  // w = type
    vec4 direction; // w = range
    vec4 color;     // w = intensity
    vec4 params;    // x=cutoff, y=outer
};

layout(std430, binding = 5) readonly buffer LightBuffer {
    Light lights[];
};
uniform int numLights;

// Lighting Helper
vec3 ComputeLighting(vec3 P, vec3 N) {
    vec3 totalLight = vec3(0.0);
    
    for(int i=0; i<numLights; ++i) {
        Light light = lights[i];
        int type = int(light.position.w);
        vec3 L;
        float attenuation = 1.0;
        
        if (type == 1) { // Directional
            L = normalize(-light.direction.xyz);
        } else { // Point or Spot
            vec3 toLight = light.position.xyz - P;
            float dist = length(toLight);
            L = normalize(toLight);
            float range = light.direction.w;
            
            // Simple linear/quadratic falloff or range-based
            if (dist > range) continue;
            
            // Attenuation
            float linear = 0.09;
            float quadratic = 0.032;
            attenuation = 1.0 / (1.0 + linear * dist + quadratic * dist * dist);
            
            // Spot
            if (type == 2) {
                float theta = dot(L, normalize(-light.direction.xyz));
                float epsilon = light.params.x - light.params.y;
                float intensity = clamp((theta - light.params.y) / epsilon, 0.0, 1.0);
                attenuation *= intensity;
            }
        }
        
        float NdotL = max(dot(N, L), 0.0);
        totalLight += light.color.rgb * light.color.w * NdotL * attenuation;
    }
    
    return totalLight;
}

void main() {
    uint rayIdx = gl_GlobalInvocationID.x;
    int totalProbes = gridDim.x * gridDim.y * gridDim.z;
    if (rayIdx >= totalProbes * raysPerProbe) return;

    int probeIdx = int(rayIdx) / raysPerProbe;
    int rayInProbe = int(rayIdx) % raysPerProbe;
    
    // Probe coord in ATLaS (Physical 0..Dim-1)
    ivec3 physCoord = GetProbeGridCoord(probeIdx, gridDim);
    
    // Toroidal World Coord Calculation
    // Logical Coord = gridOrigin + ( (physCoord - gridOrigin % dim + dim) % dim )
    // Wait, simpler:
    // We want to find the World Coord W corresponding to this Physical P.
    // W = gridOrigin + offset.
    // Offset must map to P. 
    // offset = (P - gridOrigin) mod dim?
    // Let's verify: P=0, O=1, Dim=8. Offset = (0 - 1) = -1 -> 7.
    // W = 1 + 7 = 8. Correct.
    // P=1, O=1. Offset = 0. W = 1. Correct.
    
    ivec3 offset = (physCoord - (gridOrigin % gridDim) + gridDim) % gridDim;
    ivec3 worldGridCoord = gridOrigin + offset;
    
    vec3 probePos = vec3(worldGridCoord) * probeSpacing; // + center offset?
    // usually we add 0.5 * spacing? or center?
    // MoveTo target was "bottom left" logic. 
    // We'll stick to corner for now.
    
    // Ray Direction
    vec3 baseDir = sphericalFibonacci(rayInProbe, raysPerProbe);
    vec3 dir = (randomVar * vec4(baseDir, 0.0)).xyz;
    
    // Trace
    // Note: We need Real Trace here. 
    // Reusing the placeholder logic:
    // If we hit "Floor":
    if (dir.y < 0.0) {
        float t = -probePos.y / dir.y;
        if (t > 0.0 && t < dist) {
            dist = t;
            vec3 hitPos = probePos + dir * t;
            vec3 hitNormal = vec3(0, 1, 0);
            
            vec3 albedo = vec3(0.5); // Grey floor
            vec3 directLight = ComputeLighting(hitPos, hitNormal);
            
            // Ambient (Sky)
            vec3 ambient = vec3(0.05); // low ambient
            
            radiance = albedo * (directLight + ambient);
        }
    } else {
        // Sky
        radiance = mix(vec3(0.8, 0.9, 1.0), vec3(0.1, 0.3, 0.8), dir.y);
    }
    
    hits[rayIdx].val = vec4(radiance, dist);
}
