#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba32f) readonly uniform image2D u_Input; // Final FFT result
layout(binding = 1, rgba32f) writeonly uniform image2D u_Displacement;
layout(binding = 2, rgba16f) writeonly uniform image2D u_Normal;

uniform int u_N;
uniform float u_Choppiness;

void main() {
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    if (id.x >= u_N || id.y >= u_N) return;
    
    // Get complex value from FFT
    vec2 h = imageLoad(u_Input, id).xy;
    
    // Sign flip for centered FFT (checkerboard)
    // If using centered input, output is multiplied by (-1)^(x+y)
    int sign = ((id.x + id.y) % 2 == 0) ? 1 : -1;
    float h_real = h.x * float(sign);
    
    // NOTE: This assumes we just did Height FFT.
    // In full implementation we have X, Y, Z displacements.
    // For now, only Y (Height) is real. X, Z are 0.
    
    vec3 displacement = vec3(0.0, h_real, 0.0);
    
    // Calculate Normal from Derivatives (Finite Transform or Finite Difference)
    // Simple Finite Difference on the generated displacement map is easier if we don't do derivative FFTs.
    // But we are in "Inversion", we can't do finite difference effectively without neighbors (sync issues).
    // Better to store displacement, then do normal calc in a separate pass or in Vertex shader?
    // Or assume we computed Normals via FFT slopes (requires 2 more FFTs for slopes).
    
    imageStore(u_Displacement, id, vec4(displacement, 1.0));
    
    // Placeholder Normal (Up)
    imageStore(u_Normal, id, vec4(0.0, 1.0, 0.0, 1.0));
}
