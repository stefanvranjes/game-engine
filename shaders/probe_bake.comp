#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// === Structures ===

struct ProbeData {
    vec3 position;
    float padding1;
    float shCoefficients[27]; // 27 floats
    uint flags;
    float radius;
    float padding2[2]; // Align to larger size if needed
};

// Simplified probe pos input
struct ProbeInfo {
    vec4 positionRadius; // xyz = pos, w = radius
};

struct BVHNode {
    vec4 aabbMin;   // xyz = min, w = leftChild (if < 0, leaf)
    vec4 aabbMax;   // xyz = max, w = rightChild/firstPrim
    ivec4 data;     // x = leftChild, y = rightChild, z = firstPrim, w = primCount
};

struct Vertex {
    vec4 position; // xyz, w unused
};

struct Normal {
    vec4 normal; // xyz, w unused
};

struct Material {
    vec4 albedo; // rgb, w unused
};

struct Triangle {
    uint v0, v1, v2;
    uint materialIndex;
};

// === Buffers ===

layout(std430, binding = 0) readonly buffer ProbePositions {
    ProbeInfo probes[];
};

layout(std430, binding = 1) readonly buffer SceneVertices {
    Vertex vertices[];
};

layout(std430, binding = 2) readonly buffer SceneIndices {
    uint indices[];
};

layout(std430, binding = 3) readonly buffer SceneNormals {
    Normal normals[];
};

layout(std430, binding = 4) readonly buffer SceneMaterials {
    Material materials[];
};

layout(std430, binding = 5) writeonly buffer ProbeOutput {
    float outputSH[]; // Flattened array: 27 floats * numProbes
};

layout(std430, binding = 6) readonly buffer BVHData {
    BVHNode bvhNodes[];
};

layout(std430, binding = 7) readonly buffer PrimitiveIndices {
    uint primIndices[]; // Indices into the triangle list, sorted by BVH
};

// === Uniforms ===

uniform int numProbes;
uniform int u_ProbeOffset; // Offset for progressive baking
uniform int samplesPerProbe;
uniform float maxRayDistance;
uniform int numBounces;
uniform vec3 skyColorTop;
uniform vec3 skyColorHorizon;
uniform int numTriangles;

// === Constants ===

const float PI = 3.14159265359;
const float EPSILON = 1e-5;
const float FLT_MAX = 3.402823466e+38;

// === Structs for internal usage ===

struct HitInfo {
    bool hit;
    float distance;
    vec3 position;
    vec3 normal;
    vec3 albedo;
};

// === Functions ===

bool intersectBox(vec3 origin, vec3 dir, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - origin) / dir;
    vec3 tMax = (boxMax - origin) / dir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return tNear <= tFar && tFar > 0.0;
}

bool intersectTriangle(vec3 rayOrigin, vec3 rayDir, uint triIndex, out float t, out vec2 bary, out vec3 normal) {
    // Get triangle indices
    uint i0 = indices[triIndex * 3];
    uint i1 = indices[triIndex * 3 + 1];
    uint i2 = indices[triIndex * 3 + 2];

    vec3 v0 = vertices[i0].position.xyz;
    vec3 v1 = vertices[i1].position.xyz;
    vec3 v2 = vertices[i2].position.xyz;

    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 h = cross(rayDir, edge2);
    float a = dot(edge1, h);

    if (a > -EPSILON && a < EPSILON) return false;

    float f = 1.0 / a;
    vec3 s = rayOrigin - v0;
    float u = f * dot(s, h);

    if (u < 0.0 || u > 1.0) return false;

    vec3 q = cross(s, edge1);
    float v = f * dot(rayDir, q);

    if (v < 0.0 || u + v > 1.0) return false;

    t = f * dot(edge2, q);

    if (t > EPSILON) {
        bary = vec2(u, v);
        
        // Interpolate normal
        vec3 n0 = normals[i0].normal.xyz;
        vec3 n1 = normals[i1].normal.xyz;
        vec3 n2 = normals[i2].normal.xyz;
        normal = normalize(n0 * (1.0 - u - v) + n1 * u + n2 * v);
        
        return true;
    }
    return false;
}

// Stack-based BVH traversal
bool traceRay(vec3 origin, vec3 direction, out HitInfo hit) {
    hit.hit = false;
    hit.distance = maxRayDistance;
    hit.albedo = vec3(0.0);
    
    // Check if we have any nodes
    // if (bvhNodes.length() == 0) return false; // Can't check length of unsized array easily in GLSL 430 without SSBO size uniform
    
    // Stack for BVH traversal
    int stack[64];
    int stackPtr = 0;
    stack[stackPtr++] = 0; // Push root

    while (stackPtr > 0) {
        int nodeIdx = stack[--stackPtr];
        BVHNode node = bvhNodes[nodeIdx];

        if (!intersectBox(origin, direction, node.aabbMin.xyz, node.aabbMax.xyz)) {
            continue;
        }

        int count = node.data.w; // primCount
        
        if (count > 0) {
            // Leaf node
            int first = node.data.z; // firstPrim
            for (int i = 0; i < count; i++) {
                uint triIdx = primIndices[first + i];
                // Intersect triangle (we need to map triIdx to actual vertex indices)
                // In this setup, 'triIdx' IS the index into the Triangle structure or logic
                // But wait, our 'indices' buffer is just raw indices.
                // We treat triIdx as index of the triangle, so vertices are at triIdx*3
                
                float t;
                vec2 bary;
                vec3 n;
                if (intersectTriangle(origin, direction, triIdx, t, bary, n)) {
                    if (t < hit.distance) {
                        hit.distance = t;
                        hit.hit = true;
                        hit.position = origin + direction * t;
                        hit.normal = n;
                        
                        // Look up material (simplified, assuming 1 material per triangle or mesh logic)
                        // For now we assume a material buffer aligned with triangles? 
                        // Or we need a material index buffer.
                        // Let's assume simplest case: default albedo or we need to pass a material index per triangle.
                        // For this implementation, let's look up material from a buffer if possible, or just use white.
                        // We will add a todo: Proper material lookup needs triangle->material mapping.
                        // Let's assume we map simply for now or use a default.
                        // Actually, let's use the material buffer if we can.
                        // Assuming 'materials' buffer has 1 entry per triangle for now to simplify, 
                        // OR we default to white if not provided.
                        
                        // FIX: To keep it correct, we need triangle->material index. 
                        // We'll skip complex material lookup for this first GPU pass and use a default 
                        // or hack it if needed. 
                        // Plan: Just use a default grey/white for geometry, or maybe vertex colors if available?
                        // Let's use a debug color or white.
                        hit.albedo = vec3(0.8); // Default
                    }
                }
            }
        } else {
            // Internal node
            int left = node.data.x;
            int right = node.data.y;
            
            // Optimization: push far child first, then near logic could be added
            if (left != -1) stack[stackPtr++] = left;
            if (right != -1) stack[stackPtr++] = right;
        }
    }
    
    return hit.hit;
}

vec3 getSkyColor(vec3 direction) {
    float t = direction.y * 0.5 + 0.5;
    return mix(skyColorHorizon, skyColorTop, t);
}

// Fibonacci sphere sampling
vec3 generateSample(int index, int totalSamples, vec3 normal) {
    float phi = PI * (3.0 - sqrt(5.0));
    float y = 1.0 - (float(index) / float(totalSamples - 1)) * 2.0;
    float r = sqrt(1.0 - y * y);
    float theta = phi * float(index);
    
    float x = cos(theta) * r;
    float z = sin(theta) * r;
    
    vec3 p = vec3(x, y, z);
    
    // Align to normal ? Or just uniform sphere?
    // Probe baking usually wants full sphere 4pi sampling for full SH capture.
    return normalize(p);
}

// Evaluate SH basis functions L0, L1
void evaluateSH(vec3 dir, out float sh[9]) {
    // L0
    sh[0] = 0.282095;
    // L1
    sh[1] = 0.488603 * dir.y;
    sh[2] = 0.488603 * dir.z;
    sh[3] = 0.488603 * dir.x;
    
    // L2 (simplified/placeholder if needed, but we only use L1 in plan)
    sh[4] = 0.0; sh[5] = 0.0; sh[6] = 0.0; sh[7] = 0.0; sh[8] = 0.0;
}


void main() {
    uint idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;
    if (idx >= numProbes) return;

    vec3 probePos = probes[idx].positionRadius.xyz;
    
    // Accumulators for L0 and L1 (4 coeffs per channel RGB = 12 floats total to compute)
    // 3 channels R, G, B. Each has 9 coeffs (if L2), or 4 (if L1).
    // The structure expects 27 floats (9 bands * 3 channels)
    // We will compute L0..L2 but mostly populate L0/L1 as per plan.
    
    float shAcc[27];
    for(int i=0; i<27; ++i) shAcc[i] = 0.0;
    
    float weight = 4.0 * PI / float(samplesPerProbe);
    
    for (int i = 0; i < samplesPerProbe; ++i) {
        vec3 dir = generateSample(i, samplesPerProbe, vec3(0,1,0));
        
        vec3 radiance = vec3(0.0);
        HitInfo hit;
        boolean didHit = traceRay(probePos, dir, hit);
        
        if (didHit) {
             // Direct light approximation + simple diffuse
             // For a real baker, we'd recursively trace or sample lights.
             // GPU recursion is restricted. Iterative path tracing is needed for bounces.
             // For this V1 GPU baker, let's implement:
             // 1. Sky color if miss
             // 2. If hit, simple dot(N, L) lighting from a 'virtual' light or just albedo?
             // To match CPU baker, we need to pass lights.
             // Simplification: We'll output Albedo * Sky (Ambient) for now or 
             // ideally we pass a light buffer too.
             // Let's assume just Sky sampling for bounces or a simple directional light uniform?
             // Or, we settle for "Occlusion baking" effectively if we don't pass lights.
             // Let's add basic lighting check:
             
             // Simple hack: Assume 'hit.albedo' is illuminated by some ambient + Sky
             // Ideally we cast a shadow ray to the ceiling light (known pos).
             // Let's stick to Skybox lookup for missed rays, and Albedo for hit rays (maybe darkened).
             
             radiance = hit.albedo * 0.5; // Dimmer because it's reflected
             // TODO: Add bounces or proper light buffer
        } else {
             radiance = getSkyColor(dir);
        }
        
        // Encode to SH
        float shBasis[9];
        evaluateSH(dir, shBasis);
        
        // R channel
        shAcc[0] += radiance.r * shBasis[0] * weight;
        shAcc[1] += radiance.r * shBasis[1] * weight;
        shAcc[2] += radiance.r * shBasis[2] * weight;
        shAcc[3] += radiance.r * shBasis[3] * weight;
        
        // G channel
        shAcc[9] += radiance.g * shBasis[0] * weight;
        shAcc[10] += radiance.g * shBasis[1] * weight;
        shAcc[11] += radiance.g * shBasis[2] * weight;
        shAcc[12] += radiance.g * shBasis[3] * weight;
        
        // B channel
        shAcc[18] += radiance.b * shBasis[0] * weight;
        shAcc[19] += radiance.b * shBasis[1] * weight;
        shAcc[20] += radiance.b * shBasis[2] * weight;
        shAcc[21] += radiance.b * shBasis[3] * weight;
    }
    
    // Write output
    int offset = int(idx) * 27;
    for (int i = 0; i < 27; ++i) {
        outputSH[offset + i] = shAcc[i];
    }
}
