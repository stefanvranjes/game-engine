#version 330 core
layout (location = 0) out vec4 gPosition;
layout (location = 1) out vec4 gNormal;
layout (location = 2) out vec4 gAlbedoSpec;
layout (location = 3) out vec3 gEmissive;
// layout (location = 4) out vec2 gVelocity; // Skip for now? or write 0

in vec2 TexCoord;
in vec3 WorldPos;
in vec3 Normal;

uniform sampler2D u_Texture;
uniform float u_AlphaCutoff; // e.g. 0.5
uniform vec3 u_CameraPos;
uniform vec3 u_CenterPos;
uniform int u_Rows;
uniform int u_Cols;

const float PI = 3.14159265359;

void main()
{
    // 1. Calculate View Angle
    // View Vector from Object Center to Camera (XZ plane)
    vec3 viewDir = normalize(u_CameraPos - u_CenterPos);
    // Angle in degrees (0 to 360)
    // atan(z, x) returns angle from X axis.
    // We generated views rotating Object Y. 
    // Frame 0: 0 degrees. Frame 1: Step degrees.
    // If Object is rotated 0, View is from +Z (LookAt(0,0,dist)). 
    // Wait, capture code: `Mat4::LookAt(Vec3(0, 0, dist)...)` -> Camera at +Z Looking -Z.
    // So Frame 0 is Front view (from +Z).
    // Rotation logic in capture: `obj->GetTransform().rotation = Vec3(0, angle, 0);`
    // Angle 0: View from +Z sees Front.
    // Angle 90 (rotated object): View from +Z sees Left/Right?
    // If we have a view vector (Camera - Center), we need its angle relative to "Front".
    // Assuming object is static (rotation 0), Front is +Z? 
    // Angle = atan2(viewDir.x, viewDir.z) ?
    // Let's deduce:
    // viewDir = (0, 0, 1) -> atan2(0, 1) = 0. Correct. Frame 0.
    // viewDir = (1, 0, 0) -> atan2(1, 0) = 90 (PI/2). Frame i corresponding to 90 deg.
    
    // BUT we generated by ROTATING OBJECT.
    // Rotating Object +90 means we see its Left side from Front view.
    // This is equivalent to orbiting Camera -90 deg?
    // Let's align:
    // Frame 0: 0 deg rotation.
    // Frame 1: +X deg rotation.
    // If we view from +Z, we want Frame 0.
    // If we view from -X (looking +X), we effectively see the "Right" side. 
    // Which corresponds to rotating the object +90 (Left) or -90 (Right)?
    // If we rotate object +90 (CCW), its "Right" side faces +Z.
    // So Frame corresponding to +90 shows Right side.
    // ViewDir (-1, 0, 0) -> Angle 270 (-90)?
    // We need map View Angle to Frame Angle.
    
    float angle = degrees(atan(viewDir.x, viewDir.z)); // Result -180 to 180
    if (angle < 0.0) angle += 360.0;
    
    // Map to frame index
    // Total 16 frames. 360 / 16 = 22.5 deg per frame.
    float step = 360.0 / float(u_Rows * u_Cols);
    int frameIndex = int((angle + step * 0.5) / step) % (u_Rows * u_Cols);
    
    // 2. Atlas Coordinates
    int col = frameIndex % u_Cols;
    int row = frameIndex / u_Cols;
    
    // UV Mapping
    // TexCoord (0-1) needs to be scaled to (1/Cols, 1/Rows) and offset.
    // Our capture filled TILE 0 at Bottom-Left?
    // Capture loop: 
    // viewportX = col * res; 
    // viewportY = (rows - 1 - row) * res;
    // OpenGL texture coords (0,0) is bottom-left.
    // Viewport (0, 0) corresponds to bottom-left of texture.
    // So Row (from loop index / cols) 0 -> Y (rows-1)*res (Top).
    // Frame 0 was top-left?
    // Let's recheck capture logic: `viewportY = (rows - 1 - (i / cols)) * tileResolution;`
    // i=0 -> row=0 -> y = (3)*res. Top Row.
    // So Frame 0 is Top-Left.
    // Texture UV (0,1) is Top-Left.
    // We want to map current UV (0..1) to Tile UV.
    
    // Scale
    vec2 size = vec2(1.0 / float(u_Cols), 1.0 / float(u_Rows));
    
    // Offset
    // Col adds x offset.
    // Row (0 is top) means y offset?
    // If row=0 is top, y starts at 1.0 - size.y?
    // yes: OffsetY = 1.0 - (row + 1) * size.y
    
    vec2 offset = vec2(float(col) * size.x, 1.0 - float(row + 1) * size.y);
    
    vec2 atlasUV = TexCoord * size + offset;
    
    // 3. Sample
    vec4 color = texture(u_Texture, atlasUV);
    
    // Alpha discard
    if (color.a < 0.1) discard; // Strict cutoff for now
    
    // Output to G-Buffer
    gPosition = vec4(WorldPos, 1.0); // AO in alpha? 1.0 default
    gNormal = vec4(normalize(Normal), 0.5); // Roughness 0.5 default
    gAlbedoSpec.rgb = color.rgb;
    gAlbedoSpec.a = 0.0; // Metallic
    gEmissive = vec3(0.0); // No emission
}
